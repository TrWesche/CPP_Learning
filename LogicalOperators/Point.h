#pragma once

#include <iostream>
#include <string>
#include <cmath>
#include <cassert>
#include "Vector3.h"
#include <compare>

class Point
{
    friend Point operator - (const Point& a, const Point& b);
    friend Point& operator += (Point& a, const Point& b);
    friend Point& operator -= (Point& a, const Point& b);
    friend std::ostream& operator << (std::ostream& os, const Point& point); // Stream Insertion
    friend std::istream& operator >> (std::istream& is, Point& point); // Stream Extraction
    friend void operator -- (Point& a);
    friend Point operator -- (Point& a, int);

// In general you should not setup the 3 Way Comparison/Spaceship as a non-member but it is possible
    // friend auto operator <=>(const Point& a, const Point& b) {
    //     return (a.dist_to_origin() <=> b.dist_to_origin());
    // }

// Comparison Operator Overloads (Old Way)
    // friend bool operator > (const Point& a, const Point& b);
    // friend bool operator < (const Point& a, const Point& b);
    // friend bool operator >= (const Point& a, const Point& b);
    // friend bool operator <= (const Point& a, const Point& b);
    // friend bool operator == (const Point& a, const Point& b);
    // friend bool operator != (const Point& a, const Point& b);
    // friend bool operator < (const Point& a, const double b);

// Default Equality Operator (Defaults to member wise comparison)
    // bool operator == (const Point& b) const = default;    


public:
// Constructor/Destructor
    Point();
    Point(double in_x, double in_y);
    Point(double in_x, double in_y, int in_ptr_ex);
    ~Point();

// Operator Overloads
    Point operator + (const Point& b) const;
    void operator ++ ();
    Point operator ++ (int);
    double& operator [] (size_t index);
    Point operator * (const Point& b) const;
    Point& operator = (const Point& b);

// Comparison Operator Overloads (Old Way)
    // bool operator > (const Point& b) const;
    // bool operator < (const Point& b) const;
    // bool operator >= (const Point& b) const;
    // bool operator <= (const Point& b) const;
    // bool operator == (const Point& b) const;
    // bool operator != (const Point& b) const;

// New Way (C++ 20 Or Newer)
    // Use the 3 way comparison Operator <=> (May also be called spaceship operator)
    //  - This returns a special C++ type which can be compared to a literal 0 value
    //  - Return Types:
    //      - std::strong_ordering
    //          - Used for Absolute equality comparisons / The 2 values being compared are indistinguisable
    //          - Generates all 6 comparison operators
    //          - Does not allow incomparible values
    //          - Member constants:
    //              - less
    //              - equivalent (same as equal)
    //              - equal (same as equivalent)
    //              - greater
    //      - std::weak_ordering
    //          - Used for Non-Absolute equality
    //              - ex. you could consider "Hello" and "HELLO" equivalent but not equal
    //          - Does not allow incomparible values
    //          - Member constants:
    //              - less
    //              - equivalent
    //              - greater
    //      - std::partial_ordering 
    //          - Used to describe incomparable values for a certain type
    //              - ex. You could compare a Double to a NaN type (ex. something generated by 0/0)
    //          - Defines how you want things to behave when this sort of comparison happens
    //          - Allows incomparable values
    //          - Member constancts:
    //              - less
    //              - equivalent
    //              - greater
    //              - unordered 
    //  - Library: compare
    //  - Conversions:
    //      - Implicit Conversions to more strict types to less strict types is supported, but not the opposite way
    bool operator == (const Point& b) const; // Will work for both == & != cases no matter the order of operands

    // bool operator <=> (const Point& b) const = default; // Will provide the >, >=, <, <=, and == (if defaulted)

    // In the case there is a class/type which is a member variable which does not implement the 3 way
    //      comparison operator, the compiler will try to use the > and == operators to generate the comparison
    //      for you.  This does not work with the "auto" type dedecution keyword though.  Would need to use
    //      one of the ordering types as shown below.
    // std::strong_ordering operator <=> (const Point&b) const;

    // Custom Implementation (Requires == operator implementation)
    std::partial_ordering operator <=> (const Point& b) const;


// Custom Type Conversion Overload -- Note: If in the Vector3 type a Constructor which takes a Point type is available the compiler will not know what to use and will throw errors
    explicit operator Vector3() const;


// Getter/Setters
    double get_x() const;
    double get_y() const;
    int get_ptr_example() const;

    void set_x(double in_x);
    void set_y(double in_y);
    void set_ptr_example(int in_ptr_example);

// Methods
    void print_info();

private:
// Member Variables
    double m_x;
    double m_y;
    int* ptr_example;

// Methods
    double dist_to_origin() const;
};


